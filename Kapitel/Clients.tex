Die Clients sind dafür zuständig um dem Benutzer ein Interface zu bieten, mit
dem er den Webservice nutzen kann. In Zuge dieser Arbeit werden nur graphische
Benutzerinterfaces betrachtet, da diese für die Benutzer einfacher zu erlernen
sind und auch einen einfachen Workflow bieten. Umgesetzt wurden der native
Windows-Client und ein Web-Client, der lesenden und teilweise schreibenden
Zugriff (Incident anlegen) ermöglicht.
Beschrieben wird der gemeinsame Teil, der die Daten versendet und empfängt. Die eigentlichen
Benutzeroberflächen werden dann in eigenen Kapiteln behandelt.
\subsection{Anforderungen}\label{ssec:Anforderungen_clients}
Jeder der Clients muss eine Komponente besitzen, um Daten ans Backend zu senden
und von diesem zu erhalten. Dies wird im Falle der .NET-Basierten Clients über
die HttpWebRequest-Klasse aus der System.Net-Bibliothek. Mithilfe dieser Methode
wird der Zugriff auf das Backend abstrahiert, ähnlich einer DAO-Schicht, der
TRManager\_http\_client.
Die Funktionsweise dieser Klasse wird in Kapitel \ref{sssec:http_client} auf
Seite \pageref{sssec:http_client} näher erläutert.\\
Neben der Komponente zur Kommunikation sollen die Clients es dem Anwender
ermöglichen, Vorfälle einzutragen und wieder auszutragen (entlassen). Für den
administrativen Benutzer soll zudem die Möglichkeit bestehen, Datensätze zu
verwalten (Im Sinne von bearbeiten, neue erstellen und löschen) und Daten zu
im- und exportieren. 

\subsection{Implementierung}
	Jeder im Zuge dieser Arbeit implementierte Client wurde in C\# mit dem
	.NET-Framework geschrieben, der Web-Client verwendet zusätzlich für die
	Web-Funktionalität das ASP.NET-Framework. Dies bedeutet, dass ein großer Teil
	des Codes wiederverwendet werden kann, wie etwa die Datenmodell-Klassen und die
	Methoden zum empfangen und senden von Daten über das Netzwerk (respektive über
	HTTP). Die gemeinsame Basis der Clients wird in diesem Kapitel beschrieben.
	\subsubsection{Model}
		Das Model enthält die Datenstrukturen, die vom Backend vorgegeben werden.
		Diese werden vom Backend festgelegt und müssen in den Clients exakt umgesetzt
		werden. Zu den Model-Klassen gehören wie in Kapitel \ref{sssec:model} auf
		Seite \pageref{sssec:model} beschrieben:
		\begin{itemize}
		  \item Teacher
		  \item Form (Schulklasse)
		  \item Student (Schüler)
		  \item Incident (Vorfall)
		  \item Comment (Vorgefertigter Kommentar)
		\end{itemize}
		Der einzige Unterschied zum serverseitigen Modell besteht darin, dass für die
		Basis-Klasse "`LazyObject"' (Siehe Anhang) keine Klasse implementiert wurde,
		da die Funktionalität, die LazyObject erfüllt (Flag zum Anzeigen ob das
		Objekt vollständig geladen ist und Hilfsklassen), nur auf dem Server benötigt
		wird und für den Client bis auf die vererbte ID uninterresant ist. Daraus
		ergibt sich auch die Änderung, dass die Klassen im Gegensatz zum Model im
		Backend die ID als direktes Attribut führen.\\
		\newpage
		\lstinputlisting[label=teacher_client, caption=Teacher-Model-Klasse im
		Client]{listings/Teacher.cs}
		Listing \ref{teacher_client} zeigt als
		Beispiel einen Auszug aus der Teacher-Model-Klasse des Clients. Was hierbei zu
		beachten ist, dass die Attribute exakt so benamt sind wie im Backend. Dies ist
		später für die Serialisierung und Deserialisierung der Daten mit JSON wichtig,
		da sonst die Attribute nicht richtig zugewiesen werden können. Zudem wird mit
		"`{[}JsonConstructor{]}"' der Konstruktor markiert, mit dem die Objekte
		deserialisiert werden sollen. Das Framework für die Umwandlung von Daten im
		JSON-Format wird in Kapitel \ref{ssssec:s_json} auf Seite
		\pageref{ssssec:s_json} erläutert.\\
	\subsubsection{HTTP-Client}\label{sssec:http_client}
		Der HTTP-Client ist sozusagen das "`Herstück"' der Clients. Er empfängt die
		Daten und bereitet diese für die Verwendung auf und serialisiert und sendet
		Objekte an das Backend. Es abstrahiert ähnlich einer DAO-Schicht die
		"`Abfragen"' (in diesem Kontext Web-Requests) vom Programmierer und bietet
		eine komfortable Möglichkeit, den Web-Service zu nutzen. Der HTTP-Client
		benutzt Generics und lässt sich so an fast jeden Webservice anpassen.\\
		Es wurden für die wichtigsten CRUD-Methoden (CRUD: Create, Read, Update,
		Delete) Methoden implementiert:
		\begin{itemize}
		  \item add (POST)
		  \item addBulk (POST)
		  \item edit (PUT)
		  \item delete (DELETE)
		  \item getById (GET)
		  \item getAll (GET)
		\end{itemize}
		Die grundsätzliche Funktionsweise der Methoden unterscheidet sich wieder in
		idempotente und nichtidempotente Methoden, dies wird an Auszügen der Methoden
		"`getById"' und "`add"' veranschaulicht:\\
		\lstinputlisting[label=httpclient_getbyid, caption=getById-Methode des
		Http-Clients]{listings/httpclient_idem.cs}
		Listing \ref{httpclient_getbyid} auf Seite \pageref{httpclient_getbyid} zeigt
		die getById-Methode des HTTP-Clients. Die wesentlichen Schritte bestehen im
		Erzeugen des Requests und dem Festlegen der Request-Parameter(Zeile 3), dem
		"`Abholen"' des Ergebnisses (HttpWebResponse, Zeile 4) und dem Lesen der
		Response-Daten (reader.ReadToEnd(), Zeile 10). Der so erhaltene String wird
		danach per JsonConvert (Json.NET Framework, siehe Kapitel \ref{ssssec:s_json})
		deserialisiert und zurückgegeben. Der Rückgabewert der Methode wird festgelegt
		durch den Typ, der bei Erzeugung zur Typisierung mitgegeben wurde, zum
		Beispiel Teacher. Zudem ist zu beachten dass ausser dem Query-String keine weiteren
		Informationen an das Backend geschickt werden, da diese Methode nur Daten aus
		dem Backend holt und sonst keine weiteren Änderungen vornimmt. Die anderen
		Methoden, die GET verwenden sind sehr ähnlich implementiert, diese
		unterscheiden sich nur durch einen anderen Einstiegspunkt.\\
		Anders sieht es bei der Add-Methode aus, hier werden per POST Daten an das
		Backend übermittelt:
		 \lstinputlisting[label=httpclient_add, caption=Add-Methode
		des Http-Clients]{listings/httpclient_nonidem.cs}
		Analog zur getById-Methode wird auch ein Request erzeugt, dieser benötigt aber
		weitere Informationen damit das Backend diesen versteht. Dazu gehört der
		"`ContentType"' (In welcher Form die Daten geschickt werden) und "`Accept"'
		(Legt fest in welchem Format geantwortet werden soll). Nun wird das übergebene
		Objekt serialisiert (JSON-Format) und an den Request angehängt (Zeile 10). Der
		fertige Request wird an den Server geschickt und die Antwort als Response
		gespeichert (Zeile 11). Die nun erhaltenen Daten entscheiden darüber ob die
		Methode erfolgreich war, dann erhält man das gesendete Objekt als Bestätigung
		mit ID zurück, falls nicht enthält der Response eine Server-Fehler-Nachricht
		(Internal Server Error) und die Methode bricht ab. Die anderen Methoden, die
		Daten per POST übertragen (addBulk, edit, delete) sind gleich aufgebaut, sie
		unterscheiden sich lediglich durch einen anderen Einstiegspunkt (addBulk) oder
		einer anderen HTTP-Methode (PUT, DELETE).
		\paragraph{Repository-Utility}$~~$\\\label{http_client_repo_uti}
		Die Repository-Utility-Klasse abstrahiert die Verwendung der einzelnen
		HTTP-Clients, die für jede Model-Klasse erstellt werden. Dabei bietet es
		Methoden zum Anlegen, Verändern und Löschen aller Model-Klassen(zum Beispiel
		addTeacher oder editIncident). Die Daten werden über die Methode
		"`refreshData"' vom Backend nachgeladen. Hierfür wird der Backup-Controller
		verwendet, da er innerhalb eines Requests alle Daten ausliefern
		kann. Dies führt zu einer Reduktion der Anzahl der Requests, da der Client
		sich aus den schon geladenen Daten bedienen kann und nur bei Änderungen die
		Daten nachladen muss.
		\paragraph{Json.NET Framework}$~~$\\\label{ssssec:s_json}
		Da das .NET-Framework nicht über die Möglichkeit verfügt, Daten im JSON-Format
		zu serialisieren und deserialisieren, wurde für das Projekt die Bibliothek
		"`Json.NET"' von Newtonsoft eingebunden. Es bietet die Möglichkeit, Objekte
		ins JSON-Format umzuwandeln und JSON-Strings zurück in Objekte. Hierfür muss
		lediglich die zu serialisierende/deserialisierende Klasse mit einem Flag
		versehen werden, die dem Framework den zu benutzenden Konstruktor anzeigt. Der
		Rest erfolgt automatisch, solange man die Attribut-Namen einhält, die vom
		Backend festgelegt wurden. Zudem besteht die Möglichkeit, weitere
		Konfigurationen wie zum Beispiel erweiterte Mappings und Ähnliches
		festzulegen.\\
		Im einfachsten Fall erfolgt die Serialisierung über einen Aufruf an das
		Framework ohne weitere Einstellungen:
		\begin{lstlisting}
		JsonConvert.SerializeObject(obj);
		\end{lstlisting}
		"`obj"' ist hierbei das zu serialisierende Objekt.
		Die Deserialisierung erfolgt analog dazu mit:
		\begin{lstlisting}
		JsonConvert.DeserializeObject<T>(content);
		\end{lstlisting}
		Der zurückzugebende Typ muss hier mit Generika festgelegt werden, im Falle des
		Http-Clients wird dies bei der Erzeugung festgelegt. "`content"' stellt einen
		String im JSON-Format dar, der vom Framework geparsed und anhand des
		markierten Konstruktors in ein Objekt vom Typ "`T"' umgewandelt wird.\\
		Erweiterte Konfigurationen können mit einem "`JsonSerializerSettings"'-Objekt
		festgelegt werden. 
		\begin{lstlisting}
		new JsonSerializerSettings { 
		PreserveReferencesHandling = PreserveReferencesHandling.None,
		ReferenceLoopHandling = ReferenceLoopHandling.Ignore 
		};
		\end{lstlisting}
		Hier kann zum Beispiel die Behandlungsstrategie von
		Referenzschleifen (Zirkuläre Abhängigkeiten, die zu einer Endlosrekursion
		führt) oder wie Referenzen allgemein behandelt werden sollen festgelegt
		werden.\\
		Json.NET ist Open Source-Software und wurde unter der MIT-Lizenz freigegeben
		und kann somit ohne Restriktionen in kommerzieller Software verwendet werden.
		
\cleardoublepage
