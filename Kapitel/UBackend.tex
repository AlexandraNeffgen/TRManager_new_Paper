Das Backend soll wie in Kapitel 2.3 beschrieben die Datenquelle für die
verschiedenen Clients sein. Umgesetzt werden soll dies über einen RESTful
Service. Es wird das Framework "`Spring"' eingesetzt. Dies erlaubt eine einfache
Erstellung von Web-Services und unterstützt den Programmierer mit Werkzeugen wie
Hibernate, die die Verwaltung der Datenbank stark vereinfacht und Änderungen an
der Modellierung direkt in der Datenbank umsetzt.
\subsection{Anforderungen}
Das Backend soll den Clients die Daten wie oben genannt über einen
RESTful-Service zur Verfügung stellen. Dies vereinfacht den Zugriff auf die
Ressourcen und ist leicht in bestehende Infrastrukturen einzubinden. Das Backend
soll nach Möglichkeit über \ac{HTTPS} zur Verfügung stellen, damit übertragene
Daten auf dem Weg gesichert sind. Eine Authentifizierung auf Zugriffsebene ist
optional, da der Service in einem geschlossenen Netz betrieben werden soll. Das
Backend soll zudem Authentifizierungsanfragen auf Anwendungsebene bearbeiten. 
\subsection{Implementierung}
	Das Backend wird mit dem quelloffenen Framework Spring umgesetzt. Spring bietet
	wie in Kapitel \ref{ssec:Spring} auf Seite \pageref{ssec:Spring} beschrieben
	Funktionen wie Dependency Injection und ähnliches, das die Implementierung eines
	Webservices erheblich vereinfacht. Die für dieses Projekt verwendeten Module
	umfassen Spring Boot und Spring Data. Spring Boot erlaubt die einfache
	Erstellung sofort lauffähiger Spring-Anwendungen, da hier keine komplexen
	XML-Konfigurationen vorgenommen werden müssen, und das Projekt übersichtlich
	genug, um keine komplexen Konfigurationen zu benötigen.
	\subsubsection{Model}
		Das Model legt die Datenstrukturen fest, in der der Webservice arbeitet.
		Ebenso legen diese über die annotierten Model-Klassen die Datenbankstruktur
		fest (Siehe Kapitel "`Hibernate"'). Für die Darstellung der Daten werden
		folgende Klassen benötigt:
		\begin{description}
		\item[LazyObject]
		Die LazyObject-Klasse ist die Basis-Klasse aller anderen Model-Klassen. Von
		dieser erben alle anderen Klassen. Sie legt die Grundstruktur jedes Objektes
		fest, wie zum Beispiel die ID.(Siehe Anhang, Seite \pageref{ssec:LazyObject})	 
		\item[Teacher]
		Die Teacher-Klasse stellt jeweils einen Lehrer dar. Jeder Lehrer hat einen
		Namen und eine Abkürzung. 
		\item[Form]
		Die Form-Klasse stellt jeweils eine Schulklasse dar. Jede Klasse hat einen
		Klassenlehrer, einen Namen und eine Liste mit allen in dieser Klasse
		befindlichen Schülern.
		\item[Student]
		Die Student-Klasse stellt jeweils einen Schüler dar. Gespeichert werden der
		Name des Schülers, geteilt in Vor- und Nachname, die Klasse in der der Schüler
		ist und eine Liste aller Vorfälle, in die der Schüler verwickelt ist.
		\item[Incident]
		Die Incident-Klasse stellt jeweils einen Vorfall dar. Jeder Vorfall speichert
		den schickenden Lehrer, den zugehörigen Schüler, eine interne Vorfallsnummer,
		die Ankunftszeit und Entlassungszeit sowie einen Kommentar, der den Vorfall
		selbst beschreibt und frei eingegeben werden kann.
		\item[Comment]
		Die Comment-Klasse stellt jeweils einen vorgefertigten Kommentar dar, der von
		den Clients verwendet werden kann um das Eintragen eines neuen Vorfalls zu
		vereinfachen.
		\end{description}
	\paragraph{Datenbank}
		Die Datenbank wird von Hibernate (Siehe Kapitel \ref{sssec:Hibernate}, Seite
		\pageref{sssec:Hibernate}) aus dem Objektmodell(Beschrieben in Kapitel
		\ref{ssssec:Model} auf Seite \pageref{ssssec:Model}) generiert.
		Hierzu werden die Tabellennamen, Beziehungen und die Optionen wie zum Beispiel "`Not Null"'
		mithilfe von Annotationen an Hibernate weitergegeben. Aus diesen Informationen
		erstellt Hibernate das relationale Datenmodell(Siehe Abbildung
		\ref{fig:er_model}, Seite \pageref{fig:er_model}).
	 \begin{figure}[H]
		\begin{minipage}{\linewidth}
		 	\includegraphics[width=0.9\linewidth]{grafx/ER_Model}
 			\caption[ER-Modell der Datenbank]{ER-Modell der Datenbank}
  			\label{fig:er_model}
		\end{minipage}
	\end{figure}
	\begin{description}
	\item[teacher]
		Die "`teacher"'-Tabelle hält Daten über die Lehrer vor. Dies umfasst den
		vollen Namen (name), die Abkürzung (abbreviation) und die Anrede (salutation)
	\item[form]
		Die "`form"'-Tabelle hält Daten über die Schulklassen vor, dies beinhaltet die
		Bezeichnung der Klasse (name) und einen Fremdschlüssel "`teacher\_id"', der
		den Klassenlehrer referenziert.
	\item[student]
		Die "`student"'-Tabelle hält Daten über die Schüler, die im System erfasst
		sind, vor. Dies umfasst den Namen des Schülers geteilt in Vor- und Nachname
		(givenname, surname) und einen Fremdschlüssel "`form\_id"', die die
		Schulklasse, der der Schüler angehört referenziert. Zudem wird die
		Identifikationsnummer des Schülers gespeichert, um gleichnamige Schüler
		eindeutig identifizieren zu können (schild\_id).
	\item[incident]
		In der "`incident"'-Tabelle werden alle Vorfälle gespeichert, die über den
		TRManager eingetragen werden. Dazu gehören die Ankunftszeit (arrival), der
		Zeitpunkt der "`Entlassung"' (department), den zugehörigen Schüler (\ac{FK}
		student\_id), den schickenden Lehrer (\ac{FK} teacher\_id), ein Kommentarfeld
		(comment) und eine interne Vorfallsnummer, die Ticket ID(ticket\_id).
	\item[comment]
		In der "`comment"'-Tabelle werden vorgefertigte Antworten für Vorfälle
		gespeichert. Das Feld "`text"' hält hierbei jeweils einen vorgefertigten
		Kommentar vor, der von den Clients abgerufen werden kann.
	\end{description}
	\subsubsection{Controller}
	Die Controller sind die Anlaufstelle für Anfragen über das Netzwerk und
	bearbeiten diese.
	Sie bedienen die Clients und liefern ihnen die angeforderten Daten zurück. Die
	in dieser Arbeit verwendeten Controller werden von Java beziehungsweise Spring
	(@RestController) bereitgestellt und erlauben eine einfach Zuordnung zu einer
	\ac{URI}, unter der sie ansprechbar sind sowie die Zuordnung der Methoden, die die unterschiedlichen Anfragen (zum
	Beispiel GET, POST, PUT oder DELETE) bearbeiten. 
	\paragraph{Aufbau der Controller}
	Im Allgemeinen gibt es für jede Model-Klasse einen Controller, der Daten zum
	jeweiligen Model liefern kann. Es können jedoch noch weitere Controller(oder
	weniger) definiert werden, die mehr oder weniger Funktionalität sowie
	zusätzliche, vom Datenmodell abgekoppelte, Funktionen anbieten können. So wurde
	zum Beispiel zur generellen Verwaltung des Datenbestandes ein Backup-Controller
	implementiert, der den gesamten Datenbestand in einer Anfrage ausliefern kann
	sowie löschen kann und in den Anfangszustand zurücksetzt.
	\lstinputlisting[label=controller_definition,caption=Definition
	eines Controllers]{listings/controller_definition.java}
	In Listing \ref{controller_definition} sieht man die einfache Definition eines
	Controllers. Die Klasse wird mit der "`@RestController"'-Annotation versehen,
	die dem \ac{IoC}-Container mitteilt, dass diese Klasse als \ac{REST}-Controller
	definiert ist. Die Annotation "`@RequestMapping"' legt die Adresse fest, auf
	der der Controller lauscht (In diesem Fall
	"`<hostname>/trmanager/form"') und Anfragen entgegennimmt. Die in der Klasse
	definierte Beispielmethode liefert auf eine GET-Anfrage alle Form-Objekte
	(definiert über "`method=RequestMethod.GET"') aus.	
	\paragraph{Funktionsumfang der Controller}
	Jeder Controller der einer Model-Klasse (Form, Teacher, Student, Incident)
	zugeordnet ist muss mindestens die folgenden Methoden umsetzen:\\
	\begin{itemize}
	  \item Ausliefern der Daten (getById \& getAll)
	  \item Hinzufügen von einzelnen Datensätzen (add)
	  \item Hinzufügen von mehreren Datensätzen (addBulk)
	  \item Manipulation der Daten (edit)
	  \item Löschen von Datensätzen (delete)
	\end{itemize}
	Diese werden benötigt, um den Clients die nötigen Funktionen zu bieten, um die
	Anforderungen an das Programm umzusetzen. 
	
\subsection{Tests}
Die Tests werden dazu verwendet um die Integrität und die Validatät des Backends
zu überprüfen. Hierzu wird JUnit verwendet, (Siehe Kapitel \ref{sssec:JUnit} auf
Seite \pageref{sssec:JUnit}) um automatisierte Unit-Tests durchzuführen und die
Funktionalität des Backends zu gewährleisten.\\
Zu Beginn der Tests werden Testdatensätze in die Datenbank geladen (Von der
produktiven Datenbank getrennte Instanz) und auf diesen werden dann die Tests
durchgeführt. Getestet werden die Controller (Anfragen über das Netzwerk) und
die Services beziehungsweise die Repositories. Bei den Controllern wird die
Richtigkeit der HTTP-Antworten geprüft sowie die Authentifizierung. Die Services
und Repositories werden insoweit geprüft, dass sie die Datensätze anhand der
implementierten Logik zurückgeben.
	\subsubsection{Controller-Tests}
		\paragraph{Teacher-Controller}
		\paragraph{Form-Controller}
		\paragraph{Student-Controller}
		\paragraph{Incident-Controller}
		\paragraph{Comment-Controller}
		\paragraph{User-Controller}
	\subsubsection{Service-Tests}
	\subsubsection{Repository-Tests}


\subsection{Generischer Controller ??}
 