Das Backend soll wie in Kapitel 2.3 beschrieben die Datenquelle für die
verschiedenen Clients sein. Umgesetzt werden soll dies über einen RESTful
Service. Es wird das Framework "`Spring"' eingesetzt. Dies erlaubt eine einfache
Erstellung von Web-Services und unterstützt den Programmierer mit Werkzeugen wie
Hibernate, die die Verwaltung der Datenbank stark vereinfacht und Änderungen an
der Modellierung direkt in der Datenbank umsetzt.
\subsection{Anforderungen}
Das Backend soll den Clients die Daten wie oben genannt über einen
RESTful-Service zur Verfügung stellen. Dies vereinfacht den Zugriff auf die
Ressourcen und ist leicht in bestehende Infrastrukturen einzubinden. Das Backend
soll nach Möglichkeit über \ac{HTTPS} zur Verfügung stellen, damit übertragene
Daten auf dem Weg gesichert sind. Eine Authentifizierung auf Zugriffsebene ist
optional, da der Service in einem geschlossenen Netz betrieben werden soll. Das
Backend soll zudem Authentifizierungsanfragen auf Anwendungsebene bearbeiten. 
\subsection{Implementierung}
	Das Backend wird mit dem quelloffenen Framework Spring umgesetzt. Spring bietet
	wie in Kapitel \ref{ssec:Spring} auf Seite \pageref{ssec:Spring} beschrieben
	Funktionen wie Dependency Injection und ähnliches, das die Implementierung eines
	Webservices erheblich vereinfacht. Die für dieses Projekt verwendeten Module
	umfassen Spring Boot und Spring Data. Spring Boot erlaubt die einfache
	Erstellung sofort lauffähiger Spring-Anwendungen, da hier keine komplexen
	XML-Konfigurationen vorgenommen werden müssen, und das Projekt übersichtlich
	genug, um keine komplexen Konfigurationen zu benötigen.
	\subsubsection{Model}\label{sssec:model}
		Das Model legt die Datenstrukturen fest, in der der Webservice arbeitet.
		Ebenso legen diese über die annotierten Model-Klassen die Datenbankstruktur
		fest (Siehe Kapitel "`Hibernate"'). Für die Darstellung der Daten werden
		folgende Klassen benötigt:
		\begin{description}
		\item[LazyObject]
		Die LazyObject-Klasse ist die Basis-Klasse aller anderen Model-Klassen. Von
		dieser erben alle anderen Klassen. Sie legt die Grundstruktur jedes Objektes
		fest, wie zum Beispiel die ID.(Siehe Anhang, Seite \pageref{ssec:LazyObject})	 
		\item[Teacher]
		Die Teacher-Klasse stellt jeweils einen Lehrer dar. Jeder Lehrer hat einen
		Namen und eine Abkürzung. 
		\item[Form]
		Die Form-Klasse stellt jeweils eine Schulklasse dar. Jede Klasse hat einen
		Klassenlehrer, einen Namen und eine Liste mit allen in dieser Klasse
		befindlichen Schülern.
		\item[Student]
		Die Student-Klasse stellt jeweils einen Schüler dar. Gespeichert werden der
		Name des Schülers, geteilt in Vor- und Nachname, die Klasse in der der Schüler
		ist und eine Liste aller Vorfälle, in die der Schüler verwickelt ist.
		\item[Incident]
		Die Incident-Klasse stellt jeweils einen Vorfall dar. Jeder Vorfall speichert 
		den schickenden Lehrer, den zugehörigen Schüler, eine interne Vorfallsnummer,
		die Ankunftszeit und Entlassungszeit sowie einen Kommentar, der den Vorfall
		selbst beschreibt und frei eingegeben werden kann.
		\item[Comment]
		Die Comment-Klasse stellt jeweils einen vorgefertigten Kommentar dar, der von
		den Clients verwendet werden kann um das Eintragen eines neuen Vorfalls zu
		vereinfachen.
		\end{description}
	\paragraph{Datenbank}$~~$\\
		Die Datenbank wird von Hibernate (Siehe Kapitel \ref{sssec:Hibernate}, Seite
		\pageref{sssec:Hibernate}) aus dem Objektmodell(Beschrieben in Kapitel
		\ref{ssssec:Model} auf Seite \pageref{ssssec:Model}) generiert.
		Hierzu werden die Tabellennamen, Beziehungen und die Optionen wie zum Beispiel "`Not Null"'
		mithilfe von Annotationen an Hibernate weitergegeben. Aus diesen Informationen
		erstellt Hibernate das relationale Datenmodell(Siehe Abbildung
		\ref{fig:er_model}, Seite \pageref{fig:er_model}).
	 \begin{figure}[H]
		\begin{minipage}{\linewidth}
		 	\includegraphics[width=0.9\linewidth]{grafx/ER_Model}
 			\caption[ER-Modell der Datenbank]{ER-Modell der Datenbank}
  			\label{fig:er_model}
		\end{minipage}
	\end{figure}
	\begin{description}
	\item[teacher]
		Die "`teacher"'-Tabelle hält Daten über die Lehrer vor. Dies umfasst den
		vollen Namen (name), die Abkürzung (abbreviation) und die Anrede (salutation)
	\item[form]
		Die "`form"'-Tabelle hält Daten über die Schulklassen vor, dies beinhaltet die
		Bezeichnung der Klasse (name) und einen Fremdschlüssel "`teacher\_id"', der
		den Klassenlehrer referenziert.
	\item[student]
		Die "`student"'-Tabelle hält Daten über die Schüler, die im System erfasst
		sind, vor. Dies umfasst den Namen des Schülers geteilt in Vor- und Nachname
		(givenname, surname) und einen Fremdschlüssel "`form\_id"', die die
		Schulklasse, der der Schüler angehört referenziert. Zudem wird die
		Identifikationsnummer des Schülers gespeichert, um gleichnamige Schüler
		eindeutig identifizieren zu können (schild\_id).
	\item[incident]
		In der "`incident"'-Tabelle werden alle Vorfälle gespeichert, die über den
		TRManager eingetragen werden. Dazu gehören die Ankunftszeit (arrival), der
		Zeitpunkt der "`Entlassung"' (department), den zugehörigen Schüler (\ac{FK}
		student\_id), den schickenden Lehrer (\ac{FK} teacher\_id), ein Kommentarfeld
		(comment) und eine interne Vorfallsnummer, die Ticket ID(ticket\_id).
	\item[comment]
		In der "`comment"'-Tabelle werden vorgefertigte Antworten für Vorfälle
		gespeichert. Das Feld "`text"' hält hierbei jeweils einen vorgefertigten
		Kommentar vor, der von den Clients abgerufen werden kann.
	\end{description}
	\subsubsection{Repositories}\label{sssec:repositories}
	Ein Repository stellt im Grunde die Verbindung zwischen der Datenbank
	(Hibernate) und der Anwendung selbst da. Es ist für die Zusammensetzung der
	Queries zuständig und liefert Daten zurück und schreibt Daten zurück in die
	Datenbank. Werden hier Änderungen an einem Objekt vorgenommen, werden diese
	transparent in der Datenbank geändert, hier ist also Vorsicht geboten.\\
	Um fehlerhafte Änderungen durch unsachgemäßen Gebrauch der Repositories zu
	vermeiden, wird normalerweise eine Schicht dazwischen geschoben, um davon zu
	abstrahieren(Siehe Kapitel \ref{sssec:services}, Seite
	\pageref{sssec:services}). \\
	Standardmäßig werden die Repositories von Spring mit vordefinierten
	Zugriffsmethoden generiert, um die Handhabung zu vereinfachen. Es ist aber auch
	möglich, andere Queries als die von Spring Vorgegebenen zu verwenden, zum
	Beispiel im Falle von "`schlecht"' (durch den Aufbau der Tabellen schlecht
	optimierten) Queries, um ein bessere Performance zu erreichen. Dies ist jedoch
	im Rahmen des TR-Managers nicht notwendig, da der Datenbestand relativ klein
	und auch keine komplexen Abhängigkeiten im Datenmodell bestehen.\\
	\lstinputlisting[label=repository_definition, caption=Definition eines
	Repositories]{listings/repository_definition.java}
	In Listing \ref{repository_definition} auf Seite
	\pageref{repository_definition} ist die Definition des Repositories für die
	Form-Objekte. Das Repository ist im Grunde ein Interface, das von
	"`JpaRepository"' erbt und mit Generiken versehen wird, um den Rückgabetyp und
	den "`Suchwert"' (In dem Fall Integer, die ID) festzulegen. Im Beispiel ist
	auch eine selbst-definierte Query zu sehen, diese werden mit der
	"`\@Query"'-Annotation festgelegt und werden von Spring vorrangig zur Abfrage
	verwendet. Für die restlichen Methoden (findAll, findById, delete etc.) werden
	die von Spring Data/Hibernate generierten Queries verwendet.
	\subsubsection{Services} \label{sssec:services}
	Die Services sind wie in \ref{sssec:repositories} auf Seite
	\pageref{sssec:repositories} beschrieben die Abstraktion der Repositories für
	die restliche Anwendung und behandeln Ausnahmefälle, damit diese nicht an die
	Repositories weitergereicht werden. Im einfachsten Fall reicht der Service die
	im Repository gefundenen Daten weiter an die höheren Komponenten, damit nicht
	direkt auf das Repository zugegriffen wird und direkte Manipulationen der
	Datenbank minimiert werden. Dies sollte ausschließlich über die
	"`save"'-Methode der Repositories durchgeführt werden. Weitere Funktionen die
	die Services erfüllen könnten wären höhere Konsistenzprüfungen
	(Abhängigkeiten, die nicht auf Datenbankebene definiert werden können
	beziehungsweise in der Geschäftslogik umgesetzt werden soll) sowie die
	Validierung von Daten. Dies wird in der Anwendung jedoch nicht benötigt,
	deshalb wurde darauf verzichtet.\\
	\lstinputlisting[label=service_definition, caption=Definition eines
	Services]{listings/service_definition.java}
	In Listing \ref{service_definition} auf Seite \pageref{service_definition} wird
	eine beispielhafte Definition eines Services mit einer Methode gezeigt. Die
	"`\@Service"'-Annotation markiert diese Klasse für Spring als Service. Das
	Repository-Objekt dient als Datenquelle für die Anfragen, diese wird durch den
	IoC-Container injiziert und steht automatisch zur Laufzeit zur Verfügung
	(So wie alle Objekte mit "`\@Autowired"'-Annotation). Die beispielhafte Methode
	"`getFormById"' sucht eine Schulklasse anhand ihrer ID und liefert diese
	zurück.
	\subsubsection{Controller}
	Die Controller sind die Anlaufstelle für Anfragen über das Netzwerk und
	bearbeiten diese.
	Sie bedienen die Clients und liefern ihnen die angeforderten Daten zurück. Die
	in dieser Arbeit verwendeten Controller werden von Java beziehungsweise Spring
	(@RestController) bereitgestellt und erlauben eine einfach Zuordnung zu einer
	\ac{URI}, unter der sie ansprechbar sind sowie die Zuordnung der Methoden, die die unterschiedlichen Anfragen (zum
	Beispiel GET, POST, PUT oder DELETE) bearbeiten. 
	\paragraph{Aufbau der Controller}$~~$\\
	Im Allgemeinen gibt es für jede Model-Klasse einen Controller, der Daten zum
	jeweiligen Model liefern kann. Es können jedoch noch weitere Controller(oder
	weniger) definiert werden, die mehr oder weniger Funktionalität sowie
	zusätzliche, vom Datenmodell abgekoppelte, Funktionen anbieten können. So wurde
	zum Beispiel zur generellen Verwaltung des Datenbestandes ein Backup-Controller
	implementiert, der den gesamten Datenbestand in einer Anfrage ausliefern kann
	sowie löschen kann und in den Anfangszustand zurücksetzt.
	\lstinputlisting[label=controller_definition,caption=Definition
	eines Controllers]{listings/controller_definition.java}
	In Listing \ref{controller_definition} sieht man die einfache Definition eines
	Controllers. Die Klasse wird mit der "`@RestController"'-Annotation versehen,
	die dem \ac{IoC}-Container mitteilt, dass diese Klasse als \ac{REST}-Controller
	definiert ist. Die Annotation "`@RequestMapping"' legt die Adresse fest, auf
	der der Controller lauscht (In diesem Fall
	"`<hostname>/trmanager/form"') und Anfragen entgegennimmt. Die in der Klasse
	definierte Beispielmethode liefert auf eine GET-Anfrage alle Form-Objekte
	(definiert über "`method=RequestMethod.GET"') aus.	
	\paragraph{Funktionsumfang der Controller}$~~$\\
	Jeder Controller der einer Model-Klasse (Form, Teacher, Student, Incident,
	User, Comment) zugeordnet ist muss mindestens die folgenden Methoden
	umsetzen:\\
	\begin{itemize}
	  \item Ausliefern der Daten (getById \& getAll)
	  \item Hinzufügen von einzelnen Datensätzen (add)
	  \item Hinzufügen von mehreren Datensätzen (addBulk)
	  \item Manipulation der Daten (edit)
	  \item Löschen von Datensätzen (delete)
	\end{itemize}
	Diese werden benötigt, um den Clients die nötigen Funktionen zu bieten, um die
	Anforderungen an das Programm umzusetzen. 
	
\subsection{Tests}
Die Tests werden dazu verwendet um die Integrität und die Validatät des Backends
zu überprüfen. Hierzu wird JUnit verwendet, (Siehe Kapitel \ref{sssec:JUnit} auf
Seite \pageref{sssec:JUnit}) um automatisierte Unit-Tests durchzuführen und die
Funktionalität des Backends zu gewährleisten.\\
Zu Beginn der Tests werden Testdatensätze in die Datenbank geladen (Von der
produktiven Datenbank getrennte Instanz) und auf diesen werden dann die Tests
durchgeführt. Getestet werden die Controller (Anfragen über das Netzwerk) und
die Services beziehungsweise die Repositories. Bei den Controllern wird die
Richtigkeit der HTTP-Antworten geprüft sowie die Authentifizierung. Die Services
und Repositories werden insoweit geprüft, dass sie die Datensätze anhand der
implementierten Logik zurückgeben.
	\subsubsection{Controller-Tests}
	Da die Controller die Schnittstelle zur Aussenwelt darstellen, ist hier die
	Richtigkeit der Antworten besonders wichtig. Um die einzelnen Methoden zu
	validieren wird jeder Controller und jede Methode eines Controllers überprüft.
	Zu den Überprüfungen gehören das Handling von Anfragen mit "`falschen"' Daten, die
	Richtigkeit der zurückgelieferten Daten und falsche Anfragen. Da die jeweiligen
	Controller sehr ähnlich aufgebaut sind, lässt sich hier vieles Übernehmen was
	auch für einen anderen Controller benutzt wurde.\\
	Zu Beginn eines jeden Tests wird die Datenbank neu geladen, das heisst die
	Testdaten, wie oben beschrieben, werden wiederhergestellt, damit sichergestellt
	ist dass bei Inserts keine Fehler bezüglich Duplikaten auftreten, die
	referenzierten Datensätze vorhanden sind etc.\\
	Die Tests werden mit MockMVC aus dem Spring Integration Testing durchgeführt.
	Basis für die Test bilden die Web-Requests, die sich aus dem MockMVC-Objekt
	generieren lassen (RequestBuilder). Diese werden dazu verwendet, um Anfragen an
	das Backend abzusetzen und so zu überprüfen. So kann zum Beispiel getestet
	werden, ob der Server richtig reagiert, wenn ein Objekt nicht gefunden werden
	kann (In dem Fall 404: Not found). Falls das erwartete Verhalten eintritt, ist
	der Test erfolgreich. In dem Stil werden alle Tests für jede Methode der
	Controller durchgeführt, es werden alle möglichen Ergebnisse der Controller
	"`erzwungen"'. Im Fall dieser Anwendung wären das normalerweise pro Controller
	zwei Testfälle, entweder "`Not found"' beziehungsweise "`Internal Server
	Error"' oder "`OK"'. 
		\paragraph{Teacher-Controller}\label{ssssec:test_tcontroller}$~~$\\
			Es werden alle Methoden des Teacher-Controllers getestet. Hierzu gehören:\\
			\begin{itemize}
			  \item getAllTeachers
			  \item getTeacherById
			  \item addTeacher
			  \item addBulk
			  \item editTeacher
			  \item deleteTeacher
			\end{itemize}
			Bei den Methoden, die nur Daten zurückliefern und sonst keine anderen
			Funktionen erfüllen (getAllTeachers, getTeacherById) wird überprüft, ob der
			Controller die Anfrage richtig behandelt. So soll etwa ein Fehler
			zurückgegeben werden, falls der Datensatz nicht vorhanden und vice versa für
			einen existierenden Datensatz.\\
			\lstinputlisting[label=testGetTeacherById,caption=Test
			der getById-Methode des
			Teacher-Controllers]{listings/tcontrollertestidempotent.java} 
			Listing \ref{testGetTeacherById} auf Seite \pageref{testGetTeacherById} zeigt
			den Test einer solchen idempotenten Methode. Es wird zuerst ein aus dem
			MockMVC-Objekt ein RequestBuilder generiert, der für die Erzeugung des
			Web-Requests verwendet wird. Dieser Request wird mit "`mvc.perform"'
			abgesetzt und das Ergebnis gespeichert. Dieser Vorgang wird zwei Mal
			durchgeführt, einmal mit einer ungültigen ID (50000) und einmal mit einer
			Gültigen. Die Methode "`andExpect"' ist für die Überprüfung des Status
			zuständig, hier verwendet mit "`isNotFound"' für die ungültige ID und
			"`isOK"' für die gültige.\\
			\lstinputlisting[label=testAddTeacher,caption=Test
			der Add-Methode des
			Teacher-Controllers]{listings/tcontrollertestnonidempotent.java} Analog dazu
			laufen die Tests für die nicht-idempotenten Methoden des Teacher-Controllers ab, hier muss aber anstatt eines GET-Requests ein
			POST-Request erzeugt werden und die zu übertragenden Daten serialisiert.
			Dafür sind jeweils der ObjectMapper, der PrettyPrinter und der ObjectWriter
			zuständig, die das übergebene Objekt in JSON umwandeln. Nach dem Umwandlung
			liegt das Objekt als String vor, das dem Request mitgegeben werden kann. Auch
			hier werden die zwei Testfälle behandelt, einmal mit gültigen Daten (Alle
			nötigen Werte sind gesetzt) und ungültigen Daten (Ein benötigter Wert wird
			auf null gesetzt). Der Rest des Tests ist analog zum idempotenten Test, nur
			dass hier anstelle eines "`Not found"' ein "`Internal Server Error"' geworfen
			wird.			
		\paragraph{Form-Controller}$~~$\\
			Es werden alle Methoden des Teacher-Controllers getestet. Hierzu gehören:\\
			\begin{itemize}
			  \item getAllForms
			  \item getFormById
			  \item addForm
			  \item addBulk
			  \item editForm
			  \item deleteForm
			\end{itemize}
			Die Methoden werden analog wie in Kapitel \ref{ssssec:test_tcontroller} auf
			Seite \pageref{ssssec:test_tcontroller} getestet. Auch hier wird zwischen den
			idempotenten und nichtidempotenten Methoden unterschieden.
		\paragraph{Student-Controller}$~~$\\
		   Es werden alle Methoden des Student-Controllers getestet. Hierzu gehören:\\
			\begin{itemize}
			  \item getAllStudents
			  \item getStudentById
			  \item addStudent
			  \item addBulk
			  \item editStudent
			  \item deleteStudent
			\end{itemize}
			Die Methoden werden analog wie in Kapitel \ref{ssssec:test_tcontroller} auf
			Seite \pageref{ssssec:test_tcontroller} getestet. Auch hier wird zwischen den
			idempotenten und nichtidempotenten Methoden unterschieden.
		\paragraph{Incident-Controller}$~~$\\
			Es werden alle Methoden des Incident-Controllers getestet. Hierzu gehören:\\
			\begin{itemize}
			  \item getAllIncidents
			  \item getIncidentsById
			  \item addIncident
			  \item addBulk
			  \item editIncident
			  \item deleteIncident
			\end{itemize}
			Die Methoden werden analog wie in Kapitel \ref{ssssec:test_tcontroller} auf
			Seite \pageref{ssssec:test_tcontroller} getestet. Auch hier wird zwischen den
			idempotenten und nichtidempotenten Methoden unterschieden.
		\paragraph{Comment-Controller}$~~$\\\label{ssssec:comment_controller}
			Es werden alle Methoden des Comment-Controllers getestet. Hierzu gehören:\\
			\begin{itemize}
			  \item getAllComments
			  \item getCommentById
			  \item add
			  \item addBulk
			  \item edit
			\end{itemize}
			Die Methoden werden analog wie in Kapitel \ref{ssssec:test_tcontroller} auf
			Seite \pageref{ssssec:test_tcontroller} getestet. Auch hier wird zwischen den
			idempotenten und nichtidempotenten Methoden unterschieden.
		\paragraph{User-Controller}$~~$\\
			Da der User-Controller nur über die Authenticate-Methode verfügt (Die
			Benutzer werden auf Datenbankebene eingefügt und sollen nicht geändert
			werden) muss nur diese getestet werden.\\
			\lstinputlisting[label=ucontroller_test, caption=testAuthenticate des
			User-Controllers]{listings/uControllerTest.java}
			Listing \ref{ucontroller_test} auf Seite \pageref{ucontroller_test} zeigt die
			Methode zum Testen der Authenticate-Methode des User-Controllers. Zuerst
			werden wie üblich die Hilfsobjekte zum generieren des JSON-Strings erzeugt.
			Diese werden benutzt um zwei User-Objekte zu serialisieren, einmal einen
			validen Benutzer (wird aus der Datenbank geholt) und einen Invaliden. Der
			valide Benutzer sollte ein "`OK"' vom Backend erhalten, der Invalide ein
			"`NOT\_AUTHORIZED"'. 
	\subsubsection{Service-Tests}
	\subsubsection{Repository-Tests}
 